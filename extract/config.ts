export interface Dict<T> {
  [key: string]: T;
}

export const modelMap = {
  safe: 'safe-diffusion',
  nai: 'nai-diffusion',
  furry: 'nai-diffusion-furry',
  'nai-v3': 'nai-diffusion-3',
  'nai-v4-curated-preview': 'nai-diffusion-4-curated-preview',
  'nai-v4-full': 'nai-diffusion-4-full',
} as const

export const orientMap = {
  landscape: { height: 832, width: 1216 },
  portrait: { height: 1216, width: 832 },
  square: { height: 1024, width: 1024 },
} as const

export const hordeModels = require('./data/horde-models.json') as string[]

const ucPreset = [
  'nsfw, lowres, {bad}, error, fewer, extra, missing, worst quality',
  'jpeg artifacts, bad quality, watermark, unfinished, displeasing',
  'chromatic aberration, signature, extra digits, artistic error, username, scan, [abstract]',
].join(', ')

type Model = keyof typeof modelMap
type Orient = keyof typeof orientMap

export const models = Object.keys(modelMap) as Model[]
export const orients = Object.keys(orientMap) as Orient[]

export namespace scheduler {
  export const nai = ['native', 'karras', 'exponential', 'polyexponential'] as const
  export const nai4 = ['karras', 'exponential', 'polyexponential'] as const
  export const sd = ['Automatic', 'Uniform', 'Karras', 'Exponential', 'Polyexponential', 'SGM Uniform'] as const
  export const horde = ['karras'] as const
  export const comfyUI = ['normal', 'karras', 'exponential', 'sgm_uniform', 'simple', 'ddim_uniform'] as const
}

export namespace sampler {
  export const nai = {
    'k_euler_a': 'Euler ancestral',
    'k_euler': 'Euler',
    'k_lms': 'LMS',
    'ddim': 'DDIM',
    'plms': 'PLMS',
  }

  export const nai3 = {
    'k_euler': 'Euler',
    'k_euler_a': 'Euler ancestral',
    'k_dpmpp_2s_ancestral': 'DPM++ 2S ancestral',
    'k_dpmpp_2m': 'DPM++ 2M',
    'k_dpmpp_sde': 'DPM++ SDE',
    'ddim_v3': 'DDIM V3',
  }

  export const nai4 = {
    // recommended
    'k_euler': 'Euler',
    'k_euler_a': 'Euler ancestral',
    'k_dpmpp_2s_ancestral': 'DPM++ 2S ancestral',
    'k_dpmpp_2m_sde': 'DPM++ 2M SDE',
    // other
    'k_dpmpp_2m': 'DPM++ 2M',
    'k_dpmpp_sde': 'DPM++ SDE',
  }

  // samplers in stable-diffusion-webui
  // auto-generated by `build/fetch-sd-samplers.js`
  export const sd = require('./data/sd-samplers.json') as Dict<string>

  export const horde = {
    k_lms: 'LMS',
    k_heun: 'Heun',
    k_euler: 'Euler',
    k_euler_a: 'Euler a',
    k_dpm_2: 'DPM2',
    k_dpm_2_a: 'DPM2 a',
    k_dpm_fast: 'DPM fast',
    k_dpm_adaptive: 'DPM adaptive',
    k_dpmpp_2m: 'DPM++ 2M',
    k_dpmpp_2s_a: 'DPM++ 2S a',
    k_dpmpp_sde: 'DPM++ SDE',
    dpmsolver: 'DPM solver',
    lcm: 'LCM',
    DDIM: 'DDIM',
  }

  export const comfyui = {
    euler: 'Euler',
    euler_ancestral: 'Euler ancestral',
    heun: 'Heun',
    heunpp2: 'Heun++ 2',
    dpm_2: 'DPM 2',
    dpm_2_ancestral: 'DPM 2 ancestral',
    lms: 'LMS',
    dpm_fast: 'DPM fast',
    dpm_adaptive: 'DPM adaptive',
    dpmpp_2s_ancestral: 'DPM++ 2S ancestral',
    dpmpp_sde: 'DPM++ SDE',
    dpmpp_sde_gpu: 'DPM++ SDE GPU',
    dpmpp_2m: 'DPM++ 2M',
    dpmpp_2m_sde: 'DPM++ 2M SDE',
    dpmpp_2m_sde_gpu: 'DPM++ 2M SDE GPU',
    dpmpp_3m_sde: 'DPM++ 3M SDE',
    dpmpp_3m_sde_gpu: 'DPM++ 3M SDE GPU',
    ddpm: 'DDPM',
    lcm: 'LCM',
    ddim: 'DDIM',
    uni_pc: 'UniPC',
    uni_pc_bh2: 'UniPC BH2',
  }

  export function createSchema(map: Dict<string>) {
    return Object.keys(map).reduce((acc, key) => {
      acc.push(key);
      return acc;
    }, [] as string[]);
  }

  export function sd2nai(sampler: string, model: string): string {
    if (sampler === 'k_euler_a') return 'k_euler_ancestral'
    if (model === 'nai-v3' && sampler in nai3) return sampler
    else if (sampler in nai) return sampler
    return 'k_euler_ancestral'
  }
}

export const upscalers = [
  // built-in upscalers
  'None',
  'Lanczos',
  'Nearest',
  // third-party upscalers (might not be available)
  'LDSR',
  'ESRGAN_4x',
  'R-ESRGAN General 4xV3',
  'R-ESRGAN General WDN 4xV3',
  'R-ESRGAN AnimeVideo',
  'R-ESRGAN 4x+',
  'R-ESRGAN 4x+ Anime6B',
  'R-ESRGAN 2x+',
  'ScuNET GAN',
  'ScuNET PSNR',
  'SwinIR 4x',
] as const

export const latentUpscalers = [
  'Latent',
  'Latent (antialiased)',
  'Latent (bicubic)',
  'Latent (bicubic antialiased)',
  'Latent (nearest)',
  'Latent (nearest-exact)',
]

export interface NovelAIConfig {
  type: 'token' | 'login' | 'naifu' | 'sd-webui' | 'stable-horde' | 'comfyui';
  token?: string;
  email?: string;
  password?: string;
  endpoint?: string;
  apiEndpoint?: string;
  model?: string;
  sampler?: string;
  textSteps?: number;
  imageSteps?: number;
  scale?: number;
  strength?: number;
  noise?: number;
  headers?: Record<string, string>;
  requestTimeout?: number;
  pollInterval?: number;
  trustedWorkers?: boolean;
  nsfw?: 'disallow' | 'censor' | 'allow';
  upscaler?: string;
  smea?: boolean;
  smeaDyn?: boolean;
  scheduler?: string;
  rescale?: number;
  decrisper?: boolean;
  restoreFaces?: boolean;
  hiresFix?: boolean;
  hiresFixUpscaler?: string;
  resolution?: keyof typeof orientMap | { width: number, height: number };
  maxResolution?: number;
  workflowText2Image?: string;
  workflowImage2Image?: string;
}

// 简化的提示词处理函数
export function parseForbidden(input: string) {
  return input.trim()
    .toLowerCase()
    .replace(/，/g, ',')
    .replace(/！/g, '!')
    .split(/(?:,\s*|\s*\n\s*)/g)
    .filter(Boolean)
    .map((pattern: string) => {
      const strict = pattern.endsWith('!')
      if (strict) pattern = pattern.slice(0, -1)
      pattern = pattern.replace(/[^a-z0-9\u00ff-\uffff:]+/g, ' ').trim()
      return { pattern, strict }
    })
}

// 获取词语数量
function getWordCount(words: string[]) {
  return words.join(' ').replace(/[^a-z0-9]+/g, ' ').trim().split(' ').length
}
