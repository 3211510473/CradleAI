<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>TTS SSE Client Example</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 0;
      padding: 20px;
      line-height: 1.6;
    }
    .container {
      max-width: 800px;
      margin: 0 auto;
    }
    pre {
      background-color: #f5f5f5;
      padding: 15px;
      border-radius: 5px;
      overflow: auto;
    }
    button {
      padding: 8px 16px;
      background-color: #4CAF50;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 16px;
      margin-right: 10px;
    }
    button:hover {
      background-color: #45a049;
    }
    button:disabled {
      background-color: #cccccc;
      cursor: not-allowed;
    }
    input, textarea {
      width: 100%;
      padding: 8px;
      margin-bottom: 10px;
      border: 1px solid #ddd;
      border-radius: 4px;
      box-sizing: border-box;
    }
    .status {
      margin: 20px 0;
      padding: 10px;
      background-color: #e7f3fe;
      border-left: 6px solid #2196F3;
    }
    .error {
      background-color: #ffdddd;
      border-left: 6px solid #f44336;
    }
    .success {
      background-color: #ddffdd;
      border-left: 6px solid #4CAF50;
    }
    #progress-container {
      margin-top: 20px;
    }
    #progress-bar {
      width: 0%;
      height: 30px;
      background-color: #4CAF50;
      text-align: center;
      line-height: 30px;
      color: white;
    }
    #events-log {
      height: 300px;
      overflow-y: auto;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>TTS SSE Client Example</h1>
    
    <div>
      <h2>Generate TTS</h2>
      <form id="tts-form">
        <div>
          <label for="templateId">Template ID:</label>
          <input type="text" id="templateId" name="templateId" required value="template1" />
        </div>
        
        <div>
          <label for="tts_text">Text to convert to speech:</label>
          <textarea id="tts_text" name="tts_text" rows="4" required>Hello, this is a test of the TTS system with real-time updates.</textarea>
        </div>
        
        <div>
          <label for="instruction">Instruction (optional):</label>
          <input type="text" id="instruction" name="instruction" placeholder="e.g., speak enthusiastically" />
        </div>
        
        <button type="submit" id="generate-btn">Generate Audio</button>
        <button type="button" id="retry-btn" disabled>Retry</button>
        <button type="button" id="connect-sse-btn">Connect to SSE</button>
        <button type="button" id="disconnect-sse-btn" disabled>Disconnect</button>
      </form>
    </div>
    
    <div id="status" class="status">
      Ready to generate audio
    </div>
    
    <div id="progress-container" style="display:none;">
      <h3>Progress:</h3>
      <div id="progress-bar">0%</div>
    </div>
    
    <div id="result" style="display:none;">
      <h3>Result:</h3>
      <audio id="audio-player" controls style="width: 100%;"></audio>
      <p>Audio URL: <a id="audio-url" href="#" target="_blank"></a></p>
    </div>
    
    <div>
      <h3>Event Log:</h3>
      <pre id="events-log"></pre>
    </div>
  </div>

  <script>
    // Track current task and connection state
    let currentTaskId = null;
    let eventSource = null;
    let clientId = null;
    
    // DOM elements
    const form = document.getElementById('tts-form');
    const generateBtn = document.getElementById('generate-btn');
    const retryBtn = document.getElementById('retry-btn');
    const connectSseBtn = document.getElementById('connect-sse-btn');
    const disconnectSseBtn = document.getElementById('disconnect-sse-btn');
    const statusDiv = document.getElementById('status');
    const progressContainer = document.getElementById('progress-container');
    const progressBar = document.getElementById('progress-bar');
    const resultDiv = document.getElementById('result');
    const audioPlayer = document.getElementById('audio-player');
    const audioUrl = document.getElementById('audio-url');
    const eventsLog = document.getElementById('events-log');
    
    // Function to log events
    function logEvent(event, data) {
      const timestamp = new Date().toISOString();
      const logEntry = document.createElement('div');
      logEntry.textContent = `[${timestamp}] ${event}: ${JSON.stringify(data)}`;
      eventsLog.appendChild(logEntry);
      eventsLog.scrollTop = eventsLog.scrollHeight;
    }
    
    // Update UI status
    function updateStatus(message, type = 'info') {
      statusDiv.textContent = message;
      statusDiv.className = 'status';
      if (type === 'error') {
        statusDiv.classList.add('error');
      } else if (type === 'success') {
        statusDiv.classList.add('success');
      }
    }
    
    // Update progress
    function updateProgress(percent, message = '') {
      progressContainer.style.display = 'block';
      progressBar.style.width = `${percent}%`;
      progressBar.textContent = message || `${percent}%`;
    }
    
    // Show result
    function showResult(audioUrl) {
      resultDiv.style.display = 'block';
      audioPlayer.src = audioUrl;
      document.getElementById('audio-url').href = audioUrl;
      document.getElementById('audio-url').textContent = audioUrl;
    }
    
    // Connect to SSE
    function connectToSSE() {
      if (eventSource) {
        eventSource.close();
      }
      
      // Create SSE connection with task ID if available
      const url = currentTaskId ? 
        `/events?taskId=${currentTaskId}` : 
        '/events';
      
      eventSource = new EventSource(url);
      
      eventSource.onopen = (event) => {
        logEvent('SSE Connected', {});
        updateStatus('Connected to event stream');
        connectSseBtn.disabled = true;
        disconnectSseBtn.disabled = false;
      };
      
      eventSource.addEventListener('task_update', (event) => {
        const data = JSON.parse(event.data);
        logEvent('Task Update', data);
        
        // Update UI based on task status
        updateTaskUI(data);
      });
      
      eventSource.addEventListener('connected', (event) => {
        const data = JSON.parse(event.data);
        clientId = data.clientId;
        logEvent('SSE Client ID', { clientId });
      });
      
      eventSource.addEventListener('heartbeat', (event) => {
        const data = JSON.parse(event.data);
        // We could log this but it would spam the log
        // logEvent('Heartbeat', data);
        console.log('Heartbeat received', data);
      });
      
      eventSource.onerror = (error) => {
        logEvent('SSE Error', { message: 'Connection error or server sent an error' });
        console.error('SSE error:', error);
        
        // Don't automatically reconnect when manually disconnecting
        if (!eventSource || eventSource.readyState === EventSource.CLOSED) return;
        
        // Try to reconnect
        setTimeout(() => {
          logEvent('SSE Reconnecting', {});
          connectToSSE();
        }, 3000);
      };
    }
    
    // Disconnect from SSE
    function disconnectSSE() {
      if (eventSource) {
        eventSource.close();
        eventSource = null;
        logEvent('SSE Disconnected', {});
        updateStatus('Disconnected from event stream');
        connectSseBtn.disabled = false;
        disconnectSseBtn.disabled = true;
      }
    }
    
    // Update UI based on task status
    function updateTaskUI(data) {
      const status = data.status;
      
      switch(status) {
        case 'starting':
          updateStatus(`Task starting: ${data.message}`);
          updateProgress(5, 'Starting...');
          break;
          
        case 'queued':
          updateStatus(`Task queued: ${data.message}`);
          updateProgress(10, 'Queued...');
          break;
          
        case 'dequeued':
          updateStatus(`Task dequeued: ${data.message}`);
          updateProgress(15, 'Processing...');
          break;
          
        case 'processing':
          updateStatus(`Task processing: ${data.message}`);
          if (data.progress) {
            updateProgress(data.progress, `Processing ${data.progress}%`);
          }
          break;
          
        case 'prediction_created':
          updateStatus(`Prediction created: ${data.predictionId}`);
          updateProgress(20, 'Prediction created');
          break;
          
        case 'extended_processing':
          updateStatus(`Extended processing: ${data.message}`);
          updateProgress(70, 'Extended processing...');
          break;
          
        case 'downloading':
          updateStatus(`Downloading audio: ${data.message}`);
          updateProgress(90, 'Downloading...');
          break;
          
        case 'download_complete':
          updateStatus(`Download complete: ${data.message}`);
          updateProgress(95, 'Finalizing...');
          break;
          
        case 'succeeded':
          updateStatus(`Task completed successfully!`, 'success');
          updateProgress(100, 'Complete!');
          
          if (data.output) {
            showResult(data.output);
          }
          break;
          
        case 'failed':
          updateStatus(`Task failed: ${data.error || data.message}`, 'error');
          retryBtn.disabled = false;
          break;
          
        case 'retrying':
          updateStatus(`Retrying task: ${data.message}`);
          updateProgress(data.retryCount / data.maxRetries * 50, `Retry ${data.retryCount}/${data.maxRetries}`);
          break;
          
        case 'waiting_retry':
          updateStatus(`Waiting for retry: ${data.message}`);
          updateProgress(data.retryCount / data.maxRetries * 60, `Wait for retry ${data.retryCount}/${data.maxRetries}`);
          break;
          
        case 'manual_retry':
          updateStatus(`Manual retry initiated: ${data.message}`);
          updateProgress(10, 'Retrying...');
          break;
          
        case 'cache_hit':
          updateStatus('Found in cache', 'success');
          updateProgress(100, 'Complete!');
          
          if (data.audioUrl) {
            showResult(data.audioUrl);
          }
          break;
          
        default:
          updateStatus(`Status update: ${data.status} - ${data.message}`);
      }
    }
    
    // Handle form submission
    form.addEventListener('submit', async (e) => {
      e.preventDefault();
      
      const formData = {
        templateId: document.getElementById('templateId').value,
        tts_text: document.getElementById('tts_text').value,
        instruction: document.getElementById('instruction').value || undefined
      };
      
      if (!formData.templateId || !formData.tts_text) {
        updateStatus('Please fill in all required fields', 'error');
        return;
      }
      
      try {
        // Reset UI
        generateBtn.disabled = true;
        retryBtn.disabled = true;
        resultDiv.style.display = 'none';
        updateStatus('Generating audio...');
        updateProgress(0, 'Preparing...');
        progressContainer.style.display = 'block';
        
        // Add client ID to headers if available
        const headers = {
          'Content-Type': 'application/json',
        };
        
        if (clientId) {
          headers['X-Client-ID'] = clientId;
        }
        
        // Send request
        const response = await fetch('/api/tts', {
          method: 'POST',
          headers,
          body: JSON.stringify(formData)
        });
        
        const result = await response.json();
        
        if (!result.success) {
          throw new Error(result.error || 'Failed to generate audio');
        }
        
        logEvent('API Response', result);
        
        // Store task ID for retry functionality
        if (result.data.taskId) {
          currentTaskId = result.data.taskId;
          retryBtn.disabled = false;
        }
        
        // If result has audio URL, show it immediately
        if (result.data.audio_url) {
          updateStatus('Audio generated successfully!', 'success');
          updateProgress(100, 'Complete!');
          showResult(result.data.audio_url);
        }
        // Otherwise wait for SSE updates
        else if (result.data.taskId) {
          updateStatus(`Task started with ID: ${result.data.taskId}`);
          // Ensure we're connected to SSE
          if (!eventSource || eventSource.readyState !== EventSource.OPEN) {
            connectToSSE();
          }
        }
        
      } catch (error) {
        logEvent('Error', { message: error.message });
        updateStatus(`Error: ${error.message}`, 'error');
        progressContainer.style.display = 'none';
      } finally {
        generateBtn.disabled = false;
      }
    });
    
    // Handle retry button
    retryBtn.addEventListener('click', async () => {
      if (!currentTaskId) {
        updateStatus('No task to retry', 'error');
        return;
      }
      
      try {
        retryBtn.disabled = true;
        updateStatus('Retrying audio generation...');
        updateProgress(0, 'Retrying...');
        progressContainer.style.display = 'block';
        
        const formData = {
          taskId: currentTaskId,
          templateId: document.getElementById('templateId').value,
          tts_text: document.getElementById('tts_text').value,
          instruction: document.getElementById('instruction').value || undefined
        };
        
        const response = await fetch('/api/tts/retry', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(formData)
        });
        
        const result = await response.json();
        
        if (!result.success) {
          throw new Error(result.error || 'Failed to retry audio generation');
        }
        
        logEvent('Retry Response', result);
        
        // Ensure we're connected to SSE to receive updates
        if (!eventSource || eventSource.readyState !== EventSource.OPEN) {
          connectToSSE();
        }
        
      } catch (error) {
        logEvent('Retry Error', { message: error.message });
        updateStatus(`Error: ${error.message}`, 'error');
      }
    });
    
    // Handle connect/disconnect buttons
    connectSseBtn.addEventListener('click', connectToSSE);
    disconnectSseBtn.addEventListener('click', disconnectSSE);
  </script>
</body>
</html>
